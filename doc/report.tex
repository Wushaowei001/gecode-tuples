\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{rotating}
\usepackage{tikz} \usetikzlibrary{trees}
\usepackage{pbox}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{hyperref}

\newcommand{\AnyCond}[1]{\text{Any}(#1)}
\newcommand{\BoundedCond}[1]{\text{Bounded}(#1)}
\newcommand{\Constraint}[1]{\textsc{#1}}
\newcommand{\DepProps}{\textit{DepProps}}
\newcommand{\Distinct}{\Constraint{Distinct}}
\newcommand{\Failed}{\text{Failed}}
\newcommand{\FailedCond}[1]{\text{Failed}(#1)}
\newcommand{\FixedCond}[1]{\text{Fixed}(#1)}
\newcommand{\Fixpoint}{\text{AtFixpt}}
\newcommand{\NoneCond}[1]{\text{None}(#1)}
\newcommand{\Gecode}{\textit{Gecode}}
\newcommand{\GIST}{\textit{GIST}}
\newcommand{\Propagate}{\text{Propagate}}
\newcommand{\PropConds}[1]{\text{PropConds}(#1)}
\newcommand{\Sequence}[1]{\left[#1\right]}
\newcommand{\Set}[1]{\left\{#1\right\}}
\newcommand{\Subsumed}{\text{Subsumed}}
\newcommand{\Tuple}[1]{\left\langle#1\right\rangle}
\newcommand{\Unknown}{\text{Unknown}}

\pagestyle{empty}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\title{\textbf{Implementing Tuple Variables in Gecode \\
	Bachelor Thesis \\
    Uppsala University  \\
  }
}

\author{Patrik Broman}

\date{\today}


\begin{document}
\maketitle

\begin{abstract}
Constraint programming is a programing paradigm focusing on high performance computing. There exists several different frameworks for constraint programming. Gecode is one of them, and is the one chosen for this project. In the present version of Gecode the available variable types are booleans, integers, floats and integer sets. In this thesis a new variable type - tuples - is implemented and analyzed. It is shown that for some problems, this variable type can improve performance significantly.
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents

\section*{Acknowledgements}
Thanks to Jean-No\"{e}l Monette and Pierre Flener for being helpful supervisors. \\
Thanks to Joseph Scott for helping me configuring Gecode. \\
Thanks to Johan Gustafsson for general help with C++. \\

\section{Introduction}
Intro...

\section{Background}
\subsection{Constraint Programming}

Constraint programming (CP) is a method to solve problems by modeling the problem with variables and constraints that the variables must fulfill. The variables have an initial domain of possible values. The CP solver then uses the constraints to remove impossible values. 

A very typical problem suitable for constraint programming is a sudoku. The most intuitive model is a $9\times9$ matrix of integer variables. The constraints that all variables have a domain of $\{1..9\}$, and that all variables in a row, column and box must be different. For a specific sudoku constraints are added to require specific variables to have predetermined values.

In constraint programming, different variable types may be used. Gecode comes with boolean, integer, set and float variables. The available variable types limits the options to model a specific problem. With more variable types a specific problem can be modeled in different ways. There is a problem called Eight queens\footnote{\url{https://en.wikipedia.org/wiki/Eight_queens_puzzle}}. The problem is to place eight queens on a chess board in such a way that no queen threatens another. If only boolean variables are available, the problem would have to modeled with 64 boolean variables. With integer variables it would be sufficient with only 8 variables. In the boolean case each variable $b[i][j]$ would tell if a tile has a queen or not, while in the integer case each variable $x[i]$ would tell on which row the queen in column $i$ should be placed on. By analyzing the Eight queen problem it is easy to realize that a solution must have one queen per column.

In principal the CP-solver loops propagating and branching until the problem is solved. The propagators has two main tasks. The most important task is to determine if a solution has been found or not. A solution is a state where all variables are assigned, which means their domain has been pruned (shrinked) to exactly one, and all propagators reports that the values assigned to the variables satisfies the constraints. The second task is not mandatory, but crucial for performance. A propagator can prune values from a variable's domain. For example, if a variable $x$ has a domain of $\{1..9\}$ and the constraint $x\le 4$ is used, a propagator could instantaneously remove the values $\{5..9\}$ from the domain.

When no propagator can prune any values a brancher takes over. The brancher typically splits the variable it is connected to into two parts, one with an assigned value and one with the rest of the domain, thus creating a search tree. After this branching the propagators are called again. The branchers determines the structure of the tree, and the search engine determines how the tree will be traversed. 

\subsection{Gecode}
Gecode is an open source CP solver programmed in C++ and is licensed under the MIT license. It is flexible and supports customization of most parts, including variable types, branchers and propagators. It is suitable for both education and professional use. In this thesis, Gecode 4.3.2 is used.

For more information, have a look at the homepage. \url{http://www.gecode.org}

\subsection{The need for Tuple Variables}
When using a CP solver, is is desirable to minimize the search tree to avoid brute force searching. The size of the search tree depends on the model and the propagators. With good models and propagators the variable domains can be pruned to smaller sizes, keeping the branching and searching to a minimum. For example, if two variables $x$ and $y$ have domains $dom(x)=\{1,2,3\}$ and $dom(y)=\{2,3,4\}$, and the constraint $y<x$ is applied the domains can be pruned to $dom(x)=\{3\}$ and $dom(y)=\{2\}$. If we instead have the same variables but add the constraint $x\neq y$ nothing would be pruned, since for all values in both domains there exists solutions. 

In this example the problem was modeled with two integer variables. An tuple is an ordered list of elements with fixed length. If the problem would be modeled with one tuple variable instead of two integers pruning would be possible. Then we would have a tuple variable $t$ with domain $dom(t)=\{\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle2,4\rangle,\langle3,2\rangle,\langle3,3\rangle,\langle3,4\rangle\}$ and pruning with the same constraint would yield $dom(t)=\{\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,3\rangle,\langle2,4\rangle,\langle3,2\rangle,\langle3,4\rangle\}$. This shrinks the size of the search tree from 9 to 7. 

If we instead look at the case where $dom(x),dom(y)=\{1..1000\}$ and the constraint $x=y+1$ the benefits are more obvious. Using integer variables only the values $x=1$ and $y=1000$ can be pruned. If tuple variables are used, the size of the domain would shrink from $10^6$ to $10^3$. This indicates that tuple variables can be quite useful. Note though that these two examples are selected because they are easy to understand, and in reality the performance would probably drop if tuple variables were used for them. A more realistic example is the constraint $DFA(state_1, cost_1, state_0, cost_0, token, statefun, costfun)$. It is a constraint for a dfa with cost and a solution has to satisfy $state_1= statefun(state_0, token), cost_1=cost_0+costfun(state+0, token)$. This is the constraint used in this thesis. Furthermore, the constraint is linked in several steps: $DFA(state_n, cost_n, state_{n-1}, cost_{n-1}, token_{n-1}, statefun, costfun)$

The main benefit of a tuple is the possibility to link variables together. The most obvious case is when dealing with coordinates since a coordinate by definition is a tuple, but it can be generalized to any case where it is interesting to see if a combination of two values are part of a solution.

\newpage
\section{Tuple Variables}

\subsection{Creating a New Variable in Gecode}
\subsubsection{Specification File}
Creating the specification file is the first thing that needs to be done when designing a new variable.  A simple specification file could look like this:

\begin{lstlisting}[frame=single]
[General]
Name:        IntTuple
Namespace:   MPG::IntTuple
[ModEvent]
Name:        FAILED=FAILED
[ModEvent]
Name:        VAL=ASSIGNED
[ModEvent]
Name:        NONE=NONE
[PropCond]
Name:        NONE=NONE
[PropCond]
Name:        VAL=ASSIGNED
ScheduledBy: VAL
[End]
\end{lstlisting}

There are three different sections in the file. The specification file must start with the [General] section and end with [End]. There are also sections for modification events and propagation conditions. The specification file is used by a configuration script to generate base classes.

The [General] section is trivial. This is where the name and namespace of the variable are specified. Both name and namespace are arbitrary. In Gecode the standard variables have namespace Gecode::VarName and in the examples in the documentation they instead have the namespace MPG::VarName.

The [ModEvent] section specifies the modification events. The modification events describes how the variables changes. When a propagator wants to prune the domain for a variable it tells the variable to do that, using the class methods that the variable implementation provides. If no values are pruned, the variable returns the modification event NONE, and if all values are pruned it returns FAILED. When the domain of a variable gets pruned to one ASSIGNED is returned. For all variables, modification events for NONE, FAILED and ASSIGNED are required. More modification events may be added to avoid unnecessary executions of propagators. For example, the modification event BND can be used when only the boundaries of a domain has changed.

The [PropCond] section describes how the propagators are scheduled, depending on how the variables have changed. For all variables, propagator conditions for NONE and ASSIGNED are required.

\subsubsection{Variable Implementation}
The variable implementation class would with the specification file in the previous section be called IntTupleImp and inherit from the class IntTupleVarBase generated from the specification file. It has to implement a function called assigned that returns true if the variable is assigned.
\subsubsection{Variable Class}
The variable class is the class that is used when modeling the actual problem and inherits from the variable implementation. It is a read only user interface, and a programmer that does not program any custom branchers or propagators will not use anything else than this. This class would be called IntTupleVar.
\subsubsection{Deltas}
Deltas are used for passing information about changes to improve efficiency. In this thesis an empty class is used. The only reason it is defined at all is that some virtual functions takes Deltas as arguments.

\subsubsection{Views}
The variable implementation class implements methods for modification of the variable, but the variable class does not give access to these. Instead these are called from a view, which is a read and write interface to the implementation class.

\subsubsection{Propagators}
A propagator implements constraints and prunes variables. They interact with the views and have four possible return values.
\begin{itemize}
\item{ES\_FAILED} - There are no values in the domains that satisfies the constraint. 
\item{ES\_FIX} - The propagator is at a fixpoint. It is impossible for the propagator to prune more values before the domain has changed for any of the variables the propagator depends on, by either a brancher or another propagator.
\item{ES\_NOFIX} - The propagator may be at a fixpoint, but it is not guaranteed. Running it once more may or may not prune some values. Unless it is at a fixpoint for sure, this should be used.
\item{ES\_SUBSUMED} - The propagator is done. Regardless of any changes made to the variable this particular propagator will not be able to do anything more.
\end{itemize}
The propagator must implement ES\_FAILED and at least one of the others. ES\_NOFIX is safe to return in the sense that it does not promise anything. Furthermore, the propagator needs the following methods:
\begin{itemize}
\item{post} - The method for posting a constraint, which basically is saying that a certain constraint should be used.
\item{dispose} - This works as a destructor. The only reason to not have a regular destructor is that destructors in C++ can't take arguments.
\item{copy} - A method to copy the propagator.
\item{cost} - Estimates the cost to run the propagator. This does not affect the correctness, but may improve efficiency by making it easier for the Gecode engine to schedule cheap propagators before expensive ones.
\item{propagate} - The method which does the actual work. It prunes domains and determines the status to return.
\end{itemize}
A propagator must also subscribe to views, that is, telling Gecode when the propagator should be awaken. For instance, a propagator for the constraint $x\le y$ should subscribe to the maximum value of x and minimum value of y.

\paragraph{Consistency}
A propagator can work with different consistencies. Bound consistency means that the propagator ensures that the bounds (min and max value for an integer variable) satisfies the constraint. If if $dom(x)={1,5,7,8}$ and $dom(y)={1,3,7}$ and the constraint $x=y$ is applied, the propagator would yield $dom(x)={1,5,7}$ and $dom(y)={1,3,7}$ with bounds consistency, since there are solutions to $x=1$, $x=7$, $y=1$ and $y=7$. $x=5$ and $y=3$ is not considered. Pruning the whole domain does in general cost more execution time.

\subsubsection{Branchers}
When there are no propagators able to prune any variables the CP solver must start searching. The branchers determines how this is done. The simplest brancher just puts the first value in the first branch and the rest of the values in a second branch. Another way is to pick a random value in the domain, but more sophisticated ways exist. For the IntPair variable only a simple brancher is implemented. The domain of IntPair is just a long sorted list, and the brancher picks the first value.

A brancher must implement the following methods:
\begin{itemize}
\item{status}
\item{choice}
\item{commit}
\item{print}
\item{ngl}
\end{itemize}

\subsection{Restrictions}
To keep things simple only two-dimensional integer tuples are considered, so called Pairs.

\subsection{Implementation of Exact IntPair}
The exact version does not approximate the domain, that is, the implementation is a long list of all integer pairs that's currently in the domain.

\subsection{Implementation of Approximate IntPair}
This version of IntPair approximates the domain by just storing one dimension exactly. For the other dimension, only the boundaries are stored. The benefit is vastly less use of memory, but the drawback is that it can't be pruned as efficient as the exact version. 

\subsection{Correctness verification}
The correctness is verified in several steps. For all problems an assertion is made to ensure that the solution printed actually is a solution before the solution is printed. 

\subsection{Performance Test}
To test the performance the same problem is solved in three different ways. Two of them is IntPair, one exact and one with one dimension approximated. The last one is solved with the integer variable that comes with Gecode, and is just for reference. The problem is a DFA with costs. The executables accepts six arguments: 
\begin{itemize}
\item{seed} - The seed for the random generator to generate the same DFA for all executables.
\item{states} - Number of states.
\item{tokens} - Size of the alphabet.
\item{cost} - Max cost per transition in the DFA. This is decreased by one, so setting this to 1 means no cost.
\item{max cost} - Maximum cumulative cost for the variables.
\item{steps} - Number of steps in the DFA.
\end{itemize}
\subsubsection{First Initial Performance Test}
An initial naive test with states=10, tokens=4, cost=3, max cost=10, steps=10 gave the following result:
\newline
\newline
\begin{tabular}{l r r}
int & 1m15.252s & 1 161 925 nodes\\
approx & 2m16.260s & 1 932 309 nodes\\ 
exact & 0m14.474s & 69 715 nodes \\
\end{tabular}
\newline
\newline
Another test with states=15, tokens=2, cost=20, max cost=200, steps=13 gave:
\newline
\newline
\begin{tabular}{l r r}
int & 0m53.991s &  171 357 nodes\\
approx & 0m7.351s & 108 077 nodes\\ 
exact & 0m40.735s & 8 157 nodes\\
\end{tabular}
\newline
\newline
This is very interesting. In the first test the exact version of IntPair is the clear winner, and in the second test it is the approximate version that wins. The difference is definitely significant with 14 vs 75 and 7 vs 54 seconds. What makes this even more interesting is that while the built in IntVar is highly optimised, both implementations of IntPair is the opposite. The whole variable implementation with modification events and the brancher uses poor algorithms and are just enough to get the tests to compile and run. The only code written for the builtin IntVar test is the propagator, and even that one is better written than the propagators for IntPair. While the IntPair propagators are very naive, the Int propagator uses optimisations like preallocating space for the vectors and uses binary search instead of linear search. The reason for this is to show that even with a very naive and inefficient implementation of a tuple variable, it can still be much better. The results are undoubtedly a good indication for that tuples have potential, and not a consequence of more efficient code. In the repository the commit where these tests were performed is marked with the tag FPT.

\subsection{A More Rigorous Performance Test}
For this performance test some changes have been made. The integer propagator has been optimised by replacing some of the vectors with the iterators that comes with Gecode. Furthermore, the branching is different. Now all executables branches on the token first, instead of the states. The columns are name, time in ms, number of nodes and memory usage in kB.

\begin{table}
States 15 Tokens 5 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 822 & 20 879 & 15 332 \\
exact & 938 & 20 879 & 15 784 \\
intopt & 4 697 & 146 895 & 11 576 \\
int & 13 502 & 272 063 & 11 808 \\
\end{tabular}
\end{table}

\begin{table}
States 15 Tokens 6 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 2 734 & 68 523 & 24 468 \\
exact & 3 305 & 68 523 & 26 432 \\
intopt & 16 092 & 482 543 & 11 536 \\
int & 48 974 & 893 687 & 11 852 \\
\end{tabular}
\end{table}

\begin{table}
States 15 Tokens 7 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 6 512 & 169 435 & 43 552 \\
exact & 7 890 & 169 435 & 48 436 \\
intopt & 33 471 & 1 193 363 & 11 540 \\
int & 94 656 & 2 209 935 & 11 592 \\
\end{tabular}
\end{table}

\begin{table}
States 15 Tokens 8 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 16 171 & 396 625 & 89 620 \\
exact & 19 296 & 396 625 & 99 476 \\
intopt & 89 288 & 2 791 621 & 11 540 \\
int & 278 314 & 5 170 617 & 11 520 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 924 & 20 189 & 15 656 \\
exact & 1 114 & 20 189 & 15 688 \\
intopt & 5 390 & 143 413 & 11 492 \\
int & 15 459 & 264 427 & 11 920 \\
\end{tabular}
\end{table}

\begin{table}
States 30 Tokens 5 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 1 400 & 23 833 & 16 444 \\
exact & 1 722 & 23 833 & 16 720 \\
intopt & 6 638 & 167 251 & 11 540 \\
int & 18 819 & 310 233 & 11 508 \\
\end{tabular}
\end{table}

\begin{table}
States 40 Tokens 5 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 1 788 & 24 467 & 17 052 \\
exact & 2 113 & 24 467 & 17 140 \\
intopt & 7 269 & 172 417 & 11 616 \\
int & 22 506 & 319 207 & 11 940 \\
\end{tabular}
\end{table}

\begin{table}
States 50 Tokens 5 Maxcost 3 Maxtotalcost 12 Steps 6 \\
\begin{tabular}{l r r r}
approx & 2 124 & 26 959 & 17 928 \\
exact & 2 824 & 26 959 & 17 864 \\
intopt & 8 294 & 189 809 & 11 620 \\
int & 25 228 & 351 485 & 11 492 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 2 Maxtotalcost 7 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 454 & 93 227 & 31 260 \\
exact & 3 787 & 93 227 & 30 472 \\
intopt & 29 841 & 755 629 & 11 588 \\
int & 75 422 & 1 407 969 & 11 792 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 4 Maxtotalcost 21 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 360 & 93 227 & 30 980 \\
exact & 5 754 & 93 227 & 32 216 \\
intopt & 32 078 & 755 629 & 11 576 \\
int & 120 871 & 1 408 223 & 11 872 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 6 Maxtotalcost 35 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 433 & 93 227 & 30 984 \\
exact & 8 017 & 93 227 & 33 920 \\
intopt & 34 375 & 755 629 & 11 520 \\
int & 162 428 & 1 408 225 & 11 560 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 8 Maxtotalcost 49 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 761 & 93 227 & 30 980 \\
exact & 11 252 & 93 227 & 35 356 \\
intopt & 34 747 & 755 629 & 11 584 \\
int & 201 479 & 1 408 225 & 11 544 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 15 Maxtotalcost 119 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 996 & 93 227 & 31 076 \\
exact & 19 604 & 93 227 & 36 600 \\
intopt & 38 510 & 755 629 & 11 572 \\
int & 366 591 & 1 408 225 & 11 888 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 4 Maxtotalcost 21 Steps 7 \\
\begin{tabular}{l r r r}
approx & 4 694 & 93 227 & 31 236 \\
exact & 5 594 & 93 227 & 32 472 \\
intopt & 33 072 & 755 629 & 11 524 \\
int & 122 911 & 1 408 223 & 11 940 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 4 Maxtotalcost 30 Steps 8 \\
\begin{tabular}{l r r r}
approx & 21 419 & 431 051 & 108 652 \\
exact & 25 822 & 431 051 & 113 684 \\
intopt & 178 268 & 3 924 361 & 11 492 \\
int & 754 456 & 7 372 777 & 11 864 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 4 Maxtotalcost 36 Steps 9 \\
\begin{tabular}{l r r r}
approx & 101 929 & 1 992 011 & 490 820 \\
exact & 123 114 & 1 992 011 & 514 332 \\
intopt & 996 341 & 20 128 261 & 11 572 \\
int & 4 543 939 & 38 056 369 & 11 848 \\
\end{tabular}
\end{table}

\begin{table}
States 20 Tokens 5 Maxcost 4 Maxtotalcost 42 Steps 10 \\
\begin{tabular}{l r r r}
approx & 482 644 & 9 207 489 & 2 371 316 \\
exact & 566 024 & 9 207 489 & 2 479 084 \\
intopt & 5 383 065 & 102 243 101 & 11 532 \\
int & timeout \\
\end{tabular}
\end{table}
In this table we can see advantages for IntPair. In all tests it wins over the regular integer solution in both execution time and the size of the search tree. However, it does so at the cost of higher memory usage. A node in the integer variant uses five integer nodes, while the pair variant uses two pairs and one integer. The size of a node for the integer case should roughly be equivalent to $Steps(States + Maxtotalcost)$ plus some overhead, but for the pair case the domain sizes of the pairs is equal to the number of states times the max total cost. This means that the size per node is $Steps*States*Maxtotalcost$.
\section{Related Work}
\subsection{Implementation of bit-vector variables in a CP solver}
\subsection{A propagator design framework for constraints over sequences}

\section{Conclusions and future work}

\subsection{Rewrite the implementation in such a way that it may be accepted in a new Gecode release}
All big software libraries have coding standards. There is plenty of work to rewrite the code for IntPairs in such a way that it satisfies Gecodes standards. For instance, vector from std is not allowed. Furthermore, the code is far from ready in other aspects. It contains only the methods needed to run the tests in this thesis, that is, proving that tuples actually is a good idea. One example of this is that it exists methods to get the minimum and maximum x-value for the domain, but no methods for y-value. Also, the propagators and the brancher currently only accepts arrays.

\subsection{Test different implementations with different domain representations}
In this thesis there is one exact and one approximate version. The approximation is exact in one dimension and only stores the boundaries for the second. This is just one way of doing it and there are several other ways of approximating the domain.

\subsection{Extend the tuples to arbitrary dimensions and not just pairs}
This would require a complete rewrite of the variable implementation.

\section{Git repository}
\url{http://github.com/klutt/gecode-tuples}

\begin{thebibliography}{99}
\bibitem{Calculus}
	Calculus, 
	Adams
	
\bibitem{os}
	Operating systems and its concepts,
	Galvin
\end{thebibliography}

\end{document}
