\documentclass[a4paper,11pt]{article}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{rotating}
\usepackage{tikz} \usetikzlibrary{trees}
\usepackage{pbox}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{courier}



\usepackage{siunitx}
\sisetup{per=slash, load=abbr}

\usepackage{tikz}
\usetikzlibrary{calc,angles,positioning,intersections}
\usepackage{pgfplots}
\pgfplotsset{width=7cm, height=10cm, compat=1.4, every axis/.append style={thick}}



\newcommand{\AnyCond}[1]{\text{Any}(#1)}
\newcommand{\BoundedCond}[1]{\text{Bounded}(#1)}
\newcommand{\Constraint}[1]{\textsc{#1}}
\newcommand{\DepProps}{\textit{DepProps}}
\newcommand{\Distinct}{\Constraint{Distinct}}
\newcommand{\Failed}{\text{Failed}}
\newcommand{\FailedCond}[1]{\text{Failed}(#1)}
\newcommand{\FixedCond}[1]{\text{Fixed}(#1)}
\newcommand{\Fixpoint}{\text{AtFixpt}}
\newcommand{\NoneCond}[1]{\text{None}(#1)}
\newcommand{\Gecode}{\textit{Gecode}}
\newcommand{\GIST}{\textit{GIST}}
\newcommand{\Propagate}{\text{Propagate}}
\newcommand{\PropConds}[1]{\text{PropConds}(#1)}
\newcommand{\Sequence}[1]{\left[#1\right]}
\newcommand{\Set}[1]{\left\{#1\right\}}
\newcommand{\Subsumed}{\text{Subsumed}}
\newcommand{\Tuple}[1]{\left\langle#1\right\rangle}
\newcommand{\Unknown}{\text{Unknown}}

\pagestyle{empty}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\title{\textbf{Implementing Tuple Variables in Gecode \\
	Bachelor Thesis \\
    Uppsala University  \\
  }
}

\author{Patrik Broman}

\date{\today}


\begin{document}
\maketitle

\begin{abstract}
Constraint programming is a programing paradigm focusing on high performance computing. There exists several different frameworks for constraint programming. Gecode is one of them, and is the one chosen for this project. In the present version of Gecode the available variable types are booleans, integers, floats and integer sets. In this thesis a new variable type - tuples - is implemented and analyzed. It is shown that for some problems, this variable type can improve performance significantly.
\end{abstract}

\setcounter{tocdepth}{2}
%\tableofcontents

\section*{Acknowledgements}
Thanks to Jean-No\"{e}l Monette and Pierre Flener for being helpful supervisors. \\
Thanks to Joseph Scott for helping me configuring Gecode. \\
Thanks to Johan Gustafsson for general help with C++. \\

\section{Introduction}
Intro...

\section{Background}
\subsection{Constraint Programming}

Constraint programming (CP) is a method to solve problems by modeling the problem with variables and constraints that the variables must fulfill. The variables have an initial domain of possible values. The CP solver then uses the constraints to remove impossible values. 

A very typical problem suitable for constraint programming is a sudoku. The most intuitive model is a $9\times9$ matrix of integer variables. The constraints that all variables have a domain of $\{1..9\}$, and that all variables in a row, column and box must be different. For a specific sudoku constraints are added to require specific variables to have predetermined values.

In constraint programming, different variable types may be used. Gecode comes with boolean, integer, set and float variables. The available variable types limits the options to model a specific problem. With more variable types a specific problem can be modeled in different ways. There is a problem called Eight queens\footnote{\url{https://en.wikipedia.org/wiki/Eight_queens_puzzle}}. The problem is to place eight queens on a chess board in such a way that no queen threatens another. If only boolean variables are available, the problem would have to modeled with 64 boolean variables. With integer variables it would be sufficient with only 8 variables. In the boolean case each variable $b[i][j]$ would tell if a tile has a queen or not, while in the integer case each variable $x[i]$ would tell on which row the queen in column $i$ should be placed on. By analyzing the Eight queen problem it is easy to realize that a solution must have one queen per column.

In principal the CP-solver loops propagating and branching until the problem is solved. The propagators has two main tasks. The most important task is to determine if a solution has been found or not. A solution is a state where all variables are assigned, which means their domain has been pruned (shrinked) to exactly one, and all propagators reports that the values assigned to the variables satisfies the constraints. The second task is not mandatory, but crucial for performance. A propagator can prune values from a variable's domain. For example, if a variable $x$ has a domain of $\{1..9\}$ and the constraint $x\le 4$ is used, a propagator could instantaneously remove the values $\{5..9\}$ from the domain.

When no propagator can prune any values a brancher takes over. The brancher typically splits the variable it is connected to into two parts, one with an assigned value and one with the rest of the domain, thus creating a search tree. After this branching the propagators are called again. The branchers determines the structure of the tree, and the search engine determines how the tree will be traversed. 

\subsection{Gecode}
Gecode is an open source CP solver programmed in C++ and is licensed under the MIT license. It is flexible and supports customization of most parts, including variable types, branchers and propagators. It is suitable for both education and professional use. In this thesis, Gecode 4.3.2 is used.

For more information, have a look at the homepage. \url{http://www.gecode.org}

\subsection{The need for Tuple Variables}
When using a CP solver, is is desirable to minimize the search tree to avoid brute force searching. The size of the search tree depends on the model and the propagators. With good models and propagators the variable domains can be pruned to smaller sizes, keeping the branching and searching to a minimum. For example, if two variables $x$ and $y$ have domains $dom(x)=\{1,2,3\}$ and $dom(y)=\{2,3,4\}$, and the constraint $y<x$ is applied the domains can be pruned to $dom(x)=\{3\}$ and $dom(y)=\{2\}$. If we instead have the same variables but add the constraint $x\neq y$ nothing would be pruned, since for all values in both domains there exists solutions. 

In this example the problem was modeled with two integer variables. An tuple is an ordered list of elements with fixed length. If the problem would be modeled with one tuple variable instead of two integers pruning would be possible. Then we would have a tuple variable $t$ with domain $dom(t)=\{\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle2,4\rangle,\langle3,2\rangle,\langle3,3\rangle,\langle3,4\rangle\}$ and pruning with the same constraint would yield $dom(t)=\{\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,3\rangle,\langle2,4\rangle,\langle3,2\rangle,\langle3,4\rangle\}$. This shrinks the size of the search tree from 9 to 7. 

If we instead look at the case where $dom(x),dom(y)=\{1..1000\}$ and the constraint $x=y+1$ the benefits are more obvious. Using integer variables only the values $x=1$ and $y=1000$ can be pruned. If tuple variables are used, the size of the domain would shrink from $10^6$ to $10^3$. This indicates that tuple variables can be quite useful. Note though that these two examples are selected because they are easy to understand, and in reality the performance would probably drop if tuple variables were used for them. A more realistic example is the constraint $DFA(state_1, cost_1, state_0, cost_0, token, statefun, costfun)$. It is a constraint for a dfa with cost and a solution has to satisfy $state_1= statefun(state_0, token), cost_1=cost_0+costfun(state+0, token)$. This is the constraint used in this thesis. Furthermore, the constraint is linked in several steps: $DFA(state_n, cost_n, state_{n-1}, cost_{n-1}, token_{n-1}, statefun, costfun)$

The main benefit of a tuple is the possibility to link variables together. The most obvious case is when dealing with coordinates since a coordinate by definition is a tuple, but it can be generalized to any case where it is interesting to see if a combination of two values are part of a solution.

\newpage

\subsection{Creating a New Variable in Gecode}
\subsubsection{Specification File}
Creating the specification file is the first thing that needs to be done when designing a new variable.  A simple specification file could look like this:

\begin{lstlisting}[frame=single]
[General]
Name:        IntTuple
Namespace:   MPG::IntTuple
[ModEvent]
Name:        FAILED=FAILED
[ModEvent]
Name:        VAL=ASSIGNED
[ModEvent]
Name:        NONE=NONE
[PropCond]
Name:        NONE=NONE
[PropCond]
Name:        VAL=ASSIGNED
ScheduledBy: VAL
[End]
\end{lstlisting}
There are three different sections in the file. The specification file must start with the [General] section and end with [End]. There are also sections for modification events and propagation conditions. The specification file is used by a configuration script to generate base class, from which the variable implementation class will inherit.

The [General] section is trivial. This is where the name and namespace of the variable are specified. Both name and namespace are arbitrary. In Gecode the standard variables have namespace Gecode::VarName and in the examples in the documentation they instead have the namespace MPG::VarName.

The [ModEvent] section specifies the modification events. The modification events describes how the variables changes. When a propagator wants to prune the domain for a variable it tells the variable to do that, using the class methods that the variable implementation provides. If no values are pruned, the variable returns the modification event NONE, and if all values are pruned it returns FAILED. When the domain of a variable gets pruned to one ASSIGNED is returned. For all variables, modification events for NONE, FAILED and ASSIGNED are required. More modification events may be added to avoid unnecessary executions of propagators. For example, the modification event BND can be used when only the boundaries of a domain has changed. Note that other names than the required ones are arbitrary.

The [PropCond] section describes how the propagators are scheduled, depending on how the variables have changed. For all variables, propagator conditions for NONE and ASSIGNED are required.

\subsubsection{Variable Implementation}
The variable implementation class would with the specification file in the previous section be called IntTupleImp and inherit from the class IntTupleVarBase generated from the specification file. It has to implement a function called assigned that returns true if the variable is assigned.
\subsubsection{Variable Class}
The variable class is the class that is used when modeling the actual problem and inherits from the variable implementation. It is a read only user interface, and a programmer that does not program any custom branchers or propagators will not use anything else than this. This class would be called IntTupleVar.
\subsubsection{Deltas}
Deltas are used for passing information about changes to improve efficiency. In this thesis an empty class is used. The only reason it is defined at all is that some virtual functions takes Deltas as arguments.

\subsubsection{Views}
The variable implementation class implements methods for modification of the variable, but the variable class does not give access to these. Instead these are called from a view, which is a read and write interface to the implementation class.

\subsubsection{Propagators}
A propagator implements constraints and prunes variables. They interact with the views and have four possible return values.
\begin{itemize}
\item{ES\_FAILED} - There are no values in the domains that satisfies the constraint. 
\item{ES\_FIX} - The propagator is at a fixpoint. It is impossible for the propagator to prune more values before the domain has changed for any of the variables the propagator depends on, by either a brancher or another propagator.
\item{ES\_NOFIX} - The propagator may be at a fixpoint, but it is not guaranteed. Running it once more may or may not prune some values. 
\item{ES\_SUBSUMED} - The propagator is done. Regardless of any changes made to the variables this particular propagator will not be able to do anything more.
\end{itemize}
The propagator must implement ES\_FAILED and at least one of the others. ES\_NOFIX is safe to return in the sense that it does not promise anything. Furthermore, the propagator needs the following methods:
\begin{itemize}
\item{post} - The method for posting a constraint, which basically is saying that a certain constraint should be used.
\item{dispose} - This works as a destructor. The only reason to not have a regular destructor is that destructors in C++ can't take arguments.
\item{copy} - A method to copy the propagator.
\item{cost} - Estimates the cost to run the propagator. This does not affect the correctness, but may improve efficiency by making it easier for the Gecode engine to schedule cheap propagators before expensive ones.
\item{propagate} - The method which does the actual work. It prunes domains and determines the status to return.
\end{itemize}
A propagator must also subscribe to views, that is, telling Gecode when the propagator should be awaken. For instance, a propagator for the constraint $x\le y$ should subscribe to the maximum value of x and minimum value of y.

\paragraph{Consistency}
A propagator can work with different consistencies. Bound consistency means that the propagator ensures that the bounds (min and max value for an integer variable) satisfies the constraint. If if $dom(x)={1,5,7,8}$ and $dom(y)={1,3,7}$ and the constraint $x=y$ is applied, the propagator would yield $dom(x)={1,5,7}$ and $dom(y)={1,3,7}$ with bounds consistency, since there are solutions to $x=1$, $x=7$, $y=1$ and $y=7$. $x=5$ and $y=3$ is not considered. Pruning the whole domain does in general cost more execution time.

\subsubsection{Branchers}
When there are no propagators able to prune any variables the CP solver must start searching. The branchers determines how this is done. The simplest brancher just puts the first value in the first branch and the rest of the values in a second branch. Another way is to pick a random value in the domain, but more sophisticated ways exist. For the IntPair variable only a simple brancher is implemented. The domain of IntPair is just a long sorted list, and the brancher picks the first value.

A brancher must implement the following methods:
\begin{itemize}
\item{status}
\item{choice}
\item{commit}
\item{print}
\item{ngl}
\end{itemize}

\section{The IntPair Variables}
To keep things simple only two-dimensional integer tuples are considered, so called Pairs. The specification file is kept almost as minimal as described in the introduction. None of the propagators utilizes the boundaries anyway, and there is only one propagator working for each execution in the performance test. A production ready implementation wouldThe only thing added to the specification file is the line \texttt{Dispose: true}. This is needed when using external memory resources outside Gecode, and the domains are stored as vectors from the standard library. The way Gecode is designed, the destructors for variables are never called. If a variable needs a destructor it needs to be replaced by a method called dispose. This method should explicitly call \texttt{vector::$\sim$vector()}.

\subsection{Implementation of IntPairExact}
The exact version does not approximate the domain, that is, the implementation is a long list of all integer pairs that's currently in the domain. The domain is stored as \texttt{std::vector<struct \{int x, int y\}>}. 

\paragraph{Modification Events}
\begin{itemize}
\item {\textbf{nq(Pair p) - }} Remove p from domain. $\mathcal{O}(n)$ where n is number of elements in domain.
\end{itemize}
\subsection{Implementation of IntPairApprox}
This version of IntPair approximates the domain by just storing one dimension exactly. For the other dimension, only the boundaries are stored. The benefit is less use of memory and possibly faster calculations for some problems, but the drawback is that it can't be pruned as efficient as the exact version because it can only achieve bounds consistency. The domain is stored as \texttt{std::vector<struct\{int x, int y\_low, int y\_high\}>}

\paragraph{Modification Events}
\begin{itemize}
\item {\textbf{nq(Pair p) - }} Remove p from domain. $\mathcal{O}(x)$ where x is the number of different x-values in domain.
\item{\textbf{xeq(Pair p) - }} Remove all values from domain whose y-value is not in the interval $[p.y\_low; p.y\_high]$ iff that values x-value is equal to p.x. $\mathcal{O}(x)$ where x is the number of different x-values in domain.
\item{\textbf{xeq(vector\textless Pair\textgreater v) - }} Remove all values from domain whose x-value does not exist in v. $\mathcal{O}(xm)$ where x is number of x-values in domain and m is number of elements in v.
\end{itemize}

\subsection{Implementation of DFA Propagator}
This propagator is implemented in three different ways. Two are for IntPair and one is for integer variables as reference. The algorithms are described in pseudo code:
\begin{algorithm}[H]
\caption{DFA propagator IntPairExact \newline $\mathcal{O}(\#(Post)\#(Pre)\#(Token))$}

\begin{algorithmic}[1]
\Procedure{DFAprop}{IntPairVar Post, IntPairVar Pre, IntVar Token, Statefunction S, Constfunction C}
\State Pairdomain newPost := $\emptyset$
\State Pairdomain newPre := $\emptyset$
\State Intdomain newToken := $\emptyset$
\ForAll {token in Token}
	\ForAll {pre in Pre}
		\State Pair p := (S(pre.state, token), pre.cost+C(pre.cost, token))
		\If {Post.contain(p)}
			\State newPost := newPost $\cup$ p
			\State newPre := newPre $\cup$ pre
			\State newToken := newToken $\cup$ token 
		\EndIf
	\EndFor
\EndFor
\State Post := Post $\cap$ newPost
\State Pre := Pre $\cap$ newPre
\State Token := Token $\cap$ newToken
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{DFA propagator IntPairApprox\newline $\mathcal{O}(\#(Post)\#(Pre)\#(Token))$}
\begin{algorithmic}[1]
\Procedure{Merge}{Pairdomain dom, Pair p}
\ForAll {d in dom : d.state = p.state} \# There will be max one
	\State d.high := max(d.high, p.high)
	\State d.low := min(d.low, p.low)
\EndFor
\EndProcedure
\Procedure{DFAprop}{IntPairVar Post, IntPairVar Pre, IntVar Token, Statefunction S, Constfunction C}
\State Pairdomain newPost := $\emptyset$
\State Pairdomain newPre := $\emptyset$
\State Intdomain newToken := $\emptyset$
\ForAll {token in Token}
	\ForAll {pre in Pre}
		\State Pair p := (S(pre.state, token), pre.low+C(pre.low, token), pre.high+C(pre.high, token))
		\If {p.state $\neq$ garbage}
			\State Merge(newPost, p)
			\State Merge(newPre, pre)
			\State newToken := newToken $\cup$ token 
		\EndIf
	\EndFor
\EndFor
\State Post := Post $\cap$ newPost
\State Pre := Pre $\cap$ newPre
\State Token := Token $\cap$ newToken
\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{DFA propagator IntVar\newline $\mathcal{O}(\#(PostState)\#(PostCost)\#(PreState)\#(PreCost)\#(Token))$}
\begin{algorithmic}[1]
\Procedure{DFAprop}{IntVar PostState, IntVar PostCost, IntVar PreState, IntVar PreCost, IntVar Token, Statefunction S, Constfunction C}
\State Intdomain newPostState := $\emptyset$
\State Intdomain newPreState := $\emptyset$
\State Intdomain newPostCost := $\emptyset$
\State Intdomain newPreCost := $\emptyset$
\State Intdomain newToken := $\emptyset$
\ForAll {token in Token}
	\ForAll {preState in PreState}
		\State int state := S(pre.state, token)
		\If {PostState.contain(state)}
			\State newPostState := newPostState $\cup$ state
			\State newPreState := newPreState $\cup$ pre
			\State newToken := newToken $\cup$ token 
			\ForAll {cost in PreCost}
				\State int postCost := cost + C(preState, token)
				\If {PostCost.contains(postCost)}
					\State newPreCost := newPreCost $\cup$ cost
					\State newPostCost := newPostCost $\cup$ postCost
				\EndIf
			\EndFor
		\EndIf
	\EndFor
\EndFor
\State PostState := PostState $\cap$ newPostState
\State PreState := PreState $\cap$ newPreState
\State PostCost := PostCost $\cap$ newPostCost
\State PreCost := PreCost $\cap$ newPreCost
\State Token := Token $\cap$ newToken
\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{Correctness verification}
The correctness is verified in several steps. For all problems an \texttt{assert} is used to ensure that the solution printed actually is a solution before the solution is printed. This ensures that no false solutions occur. There are a number of trivial tests in \texttt{testsrc/} with pre-calculated number of solutions. If the number of solutions are correct and all solutions fullfill the requirements the algorithms works correctly.

For bigger problems it is very hard to pre-calculate the number of solutions. Instead the tests relies on probability. The two IntPairs and one integer implementation are compared to ensure that they put out the same number of solutions, and the same solutions. It is very unlikely that they all are wrong in the exactly same way. These tests are found in \texttt{tripletestsrc/} and \texttt{multisteptestsrc/}

\subsection{Performance Test}
To test the performance the same problem is solved in three different ways. Two of them is IntPair, one exact and one with one dimension approximated. The last one is solved with the integer variable that comes with Gecode, and is just for reference. The purpose of this thesis is to show that tuples can be very useful. For that reason the reference propagator have been optimized, while the Pairs have been left with a very naive implementation. The problem is a DFA with costs. The executables accepts six arguments: 
\begin{itemize}
\item{seed} - The seed for the random generator to generate the same DFA for all executables.
\item{states} - Number of states.
\item{tokens} - Size of the alphabet.
\item{cost} - Max cost per transition in the DFA. This is decreased by one, so setting this to 1 means no cost.
\item{max cost} - Maximum cumulative cost for the variables.
\item{steps} - Number of steps in the DFA.
\end{itemize}
In all examples, the maximum total cost is set to max total cost per transition times number of steps.

\begin{figure}[H]
\begin{tikzpicture} [scale=1.8]
	\pgfplotsset{
	    scale only axis,
		legend style={at={(0,0.8)}, anchor=west, font=\tiny},
	    xmin=5, xmax=8
	}
	\begin{axis}[
	  axis y line*=left,
	  ymin=0, ymax=3000000,
	  xlabel=tokens,
	  ylabel=nodes,
	  xtick=data]
		\addplot[smooth,mark=square*, mark options={solid},red, dashdotted]
		  coordinates{
		    (5,20879)
		    (6,68523)
		    (7,169435)
		    (8,396625)
		}; \label{pnt_plot} \addlegendentry{IntPair Nodes}
		\addplot[smooth,mark=square*,mark options={solid},violet, dashdotdotted]
		  coordinates{
		    (5,146895)
		    (6,482543)
		    (7,1193363)
		    (8,2791621)
		}; \label{int_plot} \addlegendentry{Integer Nodes}
	\end{axis}
	
	\begin{axis}[
	  axis y line*=right,
	  axis x line=none,
	  ymin=0, ymax=120000,
	  ylabel=runtime (ms) ] 
	  				\addlegendimage{/pgfplots/refstyle=pnt_plot}\addlegendentry{IntPair Nodes}
	  				\addlegendimage{/pgfplots/refstyle=int_plot}\addlegendentry{Integer Nodes}
	  
	  
		\addplot[smooth,mark=*,mark options={solid},blue, dashed]
		  coordinates{
		    (5,992)
		    (6,3491)
		    (7,9352)
		    (8,23866)
		}; \label{IntPairExact Run}
		
		\addplot[smooth,mark=*,mark options={solid},green]
		  coordinates{
		    (5,827)
		    (6,2767)
		    (7,8186)
		    (8,20679)
		}; \label{IntPairApprox Run}
		
		\addplot[smooth,mark=*,mark options={solid},black, dotted]
		  coordinates{
		    (5,4770)
		    (6,17716)
		    (7,40416)
		    (8,116126)
		}; \label{IntegerRun}
	
		\addlegendentry{IntPairExact Run}
		\addlegendentry{IntPairApprox Run}
		\addlegendentry{Integer Run}
	\end{axis}
\end{tikzpicture}
\caption{{States=15, Maxcost=3, Steps=6}}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture} [scale=1.8]
	\pgfplotsset{
	    scale only axis,
		legend style={at={(0,0.4)}, anchor=west, font=\tiny},
	    xmin=20, xmax=50
	}
	\begin{axis}[
	  axis y line*=left,
	  ymin=0, ymax=200000,
	  xlabel=states,
	  ylabel=nodes,	
	  xtick=data]
		\addplot[smooth,mark=square*,mark options={solid},red, dashdotted]
		  coordinates{
		  (20,20189)
		  (30,23833)
		  (40,24467)
		  (50,26959)
		}; \label{pns_plot} \addlegendentry{IntPair Nodes}
		\addplot[smooth,mark=square*,mark options={solid},violet, dashdotdotted]
		  coordinates{
		  (20,143413)
		  (30,167251)
		  (40,172417)
		  (50,189809)
		}; \label{ins_plot} \addlegendentry{Integer Nodes}
	\end{axis}
	
	\begin{axis}[
	  axis y line*=right,
	  axis x line=none,
	  ymin=0, ymax=11000,
	  ylabel=runtime (ms) ] 
	  				\addlegendimage{/pgfplots/refstyle=pns_plot}\addlegendentry{IntPair Nodes}
	  				\addlegendimage{/pgfplots/refstyle=ins_plot}\addlegendentry{Integer Nodes}
		\addplot[smooth,mark=*,mark options={solid},blue, dashed]
		  coordinates{
		  (20,1541)
		  (30,2217)
		  (40,2593)
		  (50,3938)
		}; \label{IntPairExact Run}
		
		\addplot[smooth,mark=*,mark options={solid},green]
		  coordinates{
		  (20,1303)
		  (30,1540)
		  (40,2238)
		  (50,2653)
		}; \label{IntPairApprox Run}
		
		\addplot[smooth,mark=*,mark options={solid},black, dotted]
		  coordinates{
		  (20,6148)
		  (30,7530)
		  (40,8447)
		  (50,10086)
		}; \label{IntegerRun}
	
		\addlegendentry{IntPairExact Run}
		\addlegendentry{IntPairApprox Run}
		\addlegendentry{Integer Run}
	\end{axis}
\end{tikzpicture}
\caption{{Token=5, Maxcost=3, Steps=6}}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture} [scale=1.8]
	\pgfplotsset{
	    scale only axis,
		legend style={at={(0,0.55)}, anchor=west, font=\tiny},
	    xmin=2, xmax=15,
	  xlabel=max cost
	}
%	\begin{axis}[
%	  axis y line*=left,
%	  ymin=0, ymax=800000,
%	  ylabel=nodes,	
%	  xtick=data]
%		\addplot[smooth,mark=x,red]
%		  coordinates{
%		  (2,93227)
%		  (4,93227)
%		  (6,93227)
%		  (8,93227)
%		  (15,93227)
%		}; \label{pn_plot} \addlegendentry{IntPair Nodes}
%		\addplot[smooth,mark=x,blue]
%		  coordinates{
%		  (2,755629)
%		  (4,755629)
%		  (6,755629)
%		  (8,755629)
%		  (15,755629)
%		}; \label{in_plot} \addlegendentry{Integer Nodes}
%	\end{axis}
	
	\begin{axis}[
%	  axis y line*=right,
%	  axis x line=none,
	  ymin=0, ymax=47000,
	  ylabel=runtime (ms) ] 
%	  				\addlegendimage{/pgfplots/refstyle=pn_plot}\addlegendentry{IntPair Nodes}
%	  				\addlegendimage{/pgfplots/refstyle=in_plot}\addlegendentry{Integer Nodes} 
		\addplot[smooth,mark=*,mark options={solid},blue, dashed]
		  coordinates{
		  (2,4669)
		  (4,6994)
		  (6,9594)
		  (8,16423)
		  (15,22621)
		}; \label{IntPairExact Run}
		
		\addplot[smooth,mark=*,mark options={solid},green]
		  coordinates{
		  (2,5423)
		  (4,5143)
		  (6,5069)
		  (8,5862)
		  (15,5452)
		}; \label{IntPairApprox Run}
		
		\addplot[smooth,mark=*,mark options={solid},black, dotted]
		  coordinates{
		  (2,33288)
		  (4,38731)
		  (6,41307)
		  (8,42426)
		  (15,44868)
		}; \label{IntegerRun}
	
		\addlegendentry{IntPairExact Run}
		\addlegendentry{IntPairApprox Run}
		\addlegendentry{Integer Run}
	\end{axis}
\end{tikzpicture}
\caption{{Steps=20, Tokens=5, Steps=7. Number of nodes is omitted because it is constant. The number of nodes for Pairs are 93000 and for Integer 760000.}}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture} [scale=1.8]
	\pgfplotsset{
	    scale only axis,
		legend style={at={(0,0.8)}, anchor=west, font=\tiny},
	    xmin=7, xmax=10
	}
	\begin{axis}[
	  axis y line*=left,
	  ymin=0, ymax=120000000,
	  xlabel=steps,
	  ylabel=nodes,	
	  xtick=data]
		\addplot[smooth,mark=square*,mark options={solid},red, dashdotted]
		  coordinates{
		  (7,93227)
		  (8,431051)
		  (9,1992011)
		  (10,9207489)
		}; \label{pnc_plot} \addlegendentry{IntPair Nodes}
		\addplot[smooth,mark=square*,mark options={solid},violet, dashdotdotted]
		  coordinates{
		  (7,755629)
		  (8,3924361)
		  (9,20128261)
		  (10,102243101)
		}; \label{inc_plot} \addlegendentry{Integer Nodes}
	\end{axis}
	
	\begin{axis}[
	  axis y line*=right,
	  axis x line=none,
	  ymin=0, ymax=6100000,
	  ylabel=runtime (ms) ] 
	  				\addlegendimage{/pgfplots/refstyle=pnc_plot}\addlegendentry{IntPair Nodes}
	  				\addlegendimage{/pgfplots/refstyle=inc_plot}\addlegendentry{Integer Nodes}
		\addplot[smooth,mark=*,mark options={solid},blue, dashed]
		  coordinates{
		  (7,6535)
		  (8,32150)
		  (9,137846)
		  (10,696655)
		}; \label{IntPairExact Run}
		
		\addplot[smooth,mark=*,mark options={solid},green]
		  coordinates{
		  (7,5582)
		  (8,24569)
		  (9,116613)
		  (10,540708)
		}; \label{IntPairApprox Run}
		
		\addplot[smooth,mark=*,mark options={solid},black, dotted]
		  coordinates{
		  (7,37169)
		  (8,207591)
		  (9,1204695)
		  (10,6076224)
		}; \label{IntegerRun}
	
		\addlegendentry{IntPairExact Run}
		\addlegendentry{IntPairApprox Run}
		\addlegendentry{Integer Run}
	\end{axis}
\end{tikzpicture}
\caption{{States=20, Tokens=5, Maxcost=4}}
\end{figure}


In table we can see advantages for IntPair. In all tests it wins over the regular integer solution in both execution time and the size of the search tree. However, it does so at the cost of higher memory usage per node. A node in the integer variant uses five integer nodes, while the pair variant uses two pairs and one integer. The size of a node for the integer case should roughly be proportional to $Steps(States + Maxtotalcost)$ plus some overhead, but for the pair case the domain sizes of the pairs is proportional to the number of states times the max total cost. This means that the size per node is $Steps*States*Maxtotalcost$. Note that the tuples have a higher memory usage per node and that this does not necessarily mean that the total memory usage is higher. 

\section{Related Work}
\begin{itemize}
\item{\textbf{Implementation of bit-vector variables in a CP solver}}
\item{\textbf{A propagator design framework for constraints over sequences}}
\end{itemize}

\section{Conclusions and future work}
The tests shows that tuples show potential. Both of them perform better than the integer variant in both number of nodes and total execution time. The only flaw with this experiment is that the integer solution may not be optimized enough. There is still some room for further improvement, like implementing back propagation, but the integer variant only has one unoptimized part, which is the propagator. The IntPair variants have two. Both the propagator and the variable implementation is far from optimized. 

\subsection{Rewrite the implementation in such a way that it may be accepted in a new Gecode release}
All big software libraries have coding standards. There is plenty of work to rewrite the code for IntPairs in such a way that it satisfies Gecodes standards. For instance, vector from std is not allowed. Furthermore, the code is far from ready in other aspects. It contains only the methods needed to run the tests in this thesis, that is, proving that tuples actually is a good idea. One example of this is that it exists methods to get the minimum and maximum x-value for the domain, but no methods for y-value. Also, the propagators and the brancher currently only accepts arrays. The brancher has a bug, which manifested itself by making the program producing the same solution several times which should not be possible. This does not matter in this thesis since it is not used.

\subsection{Test different implementations with different domain representations}
In this thesis there is one exact and one approximate version. The approximation is exact in one dimension and only stores the boundaries for the second. This is just one way of doing it and there are several other ways of approximating the domain.

\subsection{Extend the tuples to arbitrary dimensions and not just pairs}
This would require a complete rewrite of the variable implementation.

\begin{thebibliography}{99}
\bibitem{Calculus}
	Calculus, 
	Adams
	
\bibitem{os}
	Operating systems and its concepts,
	Galvin
\end{thebibliography}

\end{document}
