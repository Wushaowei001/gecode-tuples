\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{rotating}
\usepackage{tikz} \usetikzlibrary{trees}
\usepackage{pbox}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{hyperref}

\newcommand{\AnyCond}[1]{\text{Any}(#1)}
\newcommand{\BoundedCond}[1]{\text{Bounded}(#1)}
\newcommand{\Constraint}[1]{\textsc{#1}}
\newcommand{\DepProps}{\textit{DepProps}}
\newcommand{\Distinct}{\Constraint{Distinct}}
\newcommand{\Failed}{\text{Failed}}
\newcommand{\FailedCond}[1]{\text{Failed}(#1)}
\newcommand{\FixedCond}[1]{\text{Fixed}(#1)}
\newcommand{\Fixpoint}{\text{AtFixpt}}
\newcommand{\NoneCond}[1]{\text{None}(#1)}
\newcommand{\Gecode}{\textit{Gecode}}
\newcommand{\GIST}{\textit{GIST}}
\newcommand{\Propagate}{\text{Propagate}}
\newcommand{\PropConds}[1]{\text{PropConds}(#1)}
\newcommand{\Sequence}[1]{\left[#1\right]}
\newcommand{\Set}[1]{\left\{#1\right\}}
\newcommand{\Subsumed}{\text{Subsumed}}
\newcommand{\Tuple}[1]{\left\langle#1\right\rangle}
\newcommand{\Unknown}{\text{Unknown}}

\pagestyle{empty}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\title{\textbf{Implementing Tuple Variables in Gecode \\
	Bachelor Thesis \\
    Uppsala University -- Autumn 2014 \\
  }
}

\author{Patrik Broman}

\date{\today}


\begin{document}
\maketitle

\begin{abstract}
This is the abstract
\end{abstract}

\tableofcontents
\section{Acknowledgements}
Thanks to Jean-NoÃ«l Monette for being a helpful supervisor. \\
Thanks to Joseph Scott for helping me with a bug. \\
\section{Introduction}
\subsection{Constraint Programming}

Constraint programming (CP) is a method to solve problems by first modeling the problem with different types of variables and then adding constraints that the variables must fulfill. The variables have an initial domain of possible values. The CP solver then uses the constraints to remove impossible values. A very typical problem suitable for constraint programming is sudoku. The most intuitive model is a 9x9 matrix of integer variables. The general constraints for all standard sudokus is that every cell has a domain of 1..9, and that all cells in a row, column and box must be different. For a specific sudoku constraints are added to require specific cells to have specific values.

The available data types limits the options to model a specific problem. With more data types a specific problem can be modeled in different ways. There is a famous problem called Queens. The problem is to place eight queens on a chess board in such a way that no queen threatens another. If only boolean variables were available we would have to model the problem with 64 boolean variables. If we instead use integer variables we can use the fact that all rows will have exactly one queen when we model the problem. This could be solved with booleans by redundant constraints, but it is more efficient to implement the constraints directly in the model.

\subsection{Terminology}
\begin{itemize}
\item{Constraint - A condition that may be hard or soft. Hard conditions must be satisfied, but soft conditions are optional.}
\item{Pruning} - Removing values from the domain of a Variable with a Propagator.
\item{Propagator} - In its simplest form it just
\item{Brancher} -
\item{Variable} -

\end{itemize}

\subsection{Gecode}
Gecode is an open source CP solver programmed in C++ and is licensed under the MIT license. It is flexible and supports customization of most parts, including data types, branchers and propagators. It is suitable for both education and professional use.

For more information, look at the homepage. \url{http://www.gecode.org}

\section{Background}
\subsection{The need for tuple variables}
When using a CP solver, one wants to avoid the brute force searching. This is done by intelligently choosing model and constraints. By doing this the variable domains can be pruned to smaller sizes. For example, if two variables $x$ and $y$ have domains $x=\{1,2,3\}$ $y=\{2,3,4\}$ and the constraint $y<x$ is added we can prune the domains to $x=\{3\}$ and $y=\{2\}$. If we instead have the same variables but add the constraint $x\neq y$ nothing would be pruned, since for all values in both domains there exists solutions. In this example the problem was modeled with two integer variables, but if the problem instead would be modeled with one tuple variable pruning would be possible. Then we would have a tuple variable $t$ with domain $t=\{<1,2>,<1,3>,<1,4>,<2,2>,<2,3>,<2,4>,<3,2>,<3,3>,<3,4>\}$ and pruning with the distinct condition would yield $t=\{<1,2>,<1,3>,<1,4>,<2,3>,<2,4>,<3,2>,<3,4>\}$. This shrinks the size of the search tree from 9 to 7. 

If we instead look at the case where $x,y=\{1..1000\}$ and the constraint $x=y$ the benefits is more obvious. Using integer variables pruning can not remove anything. If tuple variables were used, the size of the domain would shrink from $10^6$ to $10^3$. This indicates that tuple variables can be quite useful.

\section{Tuple Variable}

\subsection{Creating a new Variable}
\subsubsection{Specification file}
Creating the specification file is the first thing that needs to be done when designing a new variable. Caution should be taken, because this step may be very hard to modify later. A simple specification file could look like this.

\begin{lstlisting}[frame=single]
[General]
Name:      IntTuple
Namespace: MPG::IntTuple

[ModEvent]
Name:      FAILED=FAILED

[ModEvent]
Name:      VAL=ASSIGNED

[ModEvent]
Name:      NONE=NONE

[PropCond]
Name:      NONE=NONE
[End]
\end{lstlisting}

As can be seen, there are three sections. The specification file must start with the [General] section and end with [End]. There are also sections for modification events and propagation conditions. When the specification file is written a configuration script is used to generate base classes from the specification file.

The [General] section is pretty straight forward. This is where the name and namespace of the variable is specified. Both name and namespace is arbitrary. In Gecode the standard variables have namespace Gecode::VarName and in the examples in the documentation they instead have the namespace MPG::VarName.

The [ModEvent] section describes the modification events. For all variables modification events for NONE, FAILED and ASSIGNED are required.

The [PropCond] section describes how the propagators are scheduled.

\subsubsection{Variable implementation}
The variable implementation class would with the specification file in the previous section be called IntTupleImp and inherit from the generated class IntTupleVarBase. It has to implement a function called assigned that returns true if the variable is assigned.
\subsubsection{Variable class}
The variable class is the class that is used when modeling the actual problem and inherits from the variable implementation. It is a read only user interface, and a programmer that does not program any custom branchers or propagators will not use anything else than this. This class would be called IntTupleVar.

\subsubsection{Deltas}
\subsubsection{Views}
The variable class does not offer any methods for removing values. These methods are instead implemented in a view.
\subsubsection{Propagators}
A propagator implements constraints and prunes variables. They interact with the views and not variable class and have four possible return values.
\begin{itemize}
\item{ES\_FAILED} - There are no values in the domain that satisfies the constraint.
\item{ES\_FIX} - It is impossible for the propagator to prune more values before the domain has changed by either a brancher or another propagator.
\item{ES\_SUBSUMED} - The propagator is done. Regardless of any changes made to the variable this particular propagator will not be able to do anything more.
\item{ES\_NOFIX} - None of the others are applicable.
\end{itemize}
The propagator must implement ES\_FAILED and at least one of the others. Furthermore, the propagator needs the following methods.
\begin{itemize}
\item{post}
\item{disposal} - This works as a destructor. The only reason to not have a regular destructor is that destructors in C++ can't take arguments.
\item{copy} - A method to copy the constructor.
\item{cost} - Estimates the cost to run the propagator.
\item{propagate}
\end{itemize}

\subsubsection{Branchers}

\subsection{Implementation of exact IntPair}
The exact version does not approximate the domain, that is, the implementation is a long list of all integer pairs that's currently in the domain.

The specification is as follows.
\begin{lstlisting}[frame=single]
[General]
Name:      IntPair
Namespace: Gecode::IntPair

[ModEvent]
Name:      FAILED=FAILED

[ModEvent]
Name:      VAL=ASSIGNED

[ModEvent]
Name:      NONE=NONE

[PropCond]
Name:      NONE=NONE
[End]
\end{lstlisting}

\subsection{Restrictions}
To keep things simple only two-dimensional integer tuples are considered, so called Pairs.

\subsection{Implementation of rectangle IntPair}
This version of IntPair approximates the domain by just storing four pairs. The benefit is vastly less use of memory, but the drawback is that it can't be pruned as efficient as the exact version. Another benefit for future work is that an approximation is possible to extend to float numbers.

\subsection{Performance test}

\section{Related work}
\subsection{Implementation of bit-vector variables in a CP solver}
\subsection{A propagator design framework for constraints over sequences}

\section{Conclusions and future work}

\subsection{Write the implementation in such a way that it may be accepted in a new Gecode release}
\subsection{Test different implementations with different domain representations}
\subsection{Extend the tuples to arbitrary dimensions and not just pairs}
\subsection{Extend the tuples to floats}
\subsection{Reach better performance for a specific problem with an array of pair variables than with two arrays of integer variables}

\section{Git repository}
\url{http://github.com/patwotrik/gecode-tuples}

\section{Legal}
This document is licensed under GPL v3 and may be redistributed as GPL v3 or later. 


\begin{thebibliography}{99}
\bibitem{Calculus}
	Calculus, 
	Adams
	
\bibitem{os}
	Operating systems and its concepts,
	Galvin
	
\end{thebibliography}

\end{document}
